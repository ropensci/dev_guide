# Guía de embalaje {#construcción}

```{block, type="summaryblock"}
rOpenSci acepta paquetes que cumplen nuestras directrices a través de un [proceso de revisión por pares del software] racionalizado (#whatissoftwarereview). Para garantizar un estilo coherente en todas nuestras herramientas, hemos escrito este capítulo que destaca nuestras directrices para el desarrollo de paquetes. Por favor, lee también y aplica nuestro [capítulo sobre integración continua (IC)](#ci). En la tercera sección de este libro, que comienza con [un capítulo sobre la colaboración](#colaboración), se ofrecen más orientaciones para después del proceso de revisión.

Recomendamos encarecidamente a los desarrolladores de paquetes que lean el conciso pero exhaustivo libro de Hadley Wickham y Jenny Bryan sobre el desarrollo de paquetes, que está disponible [gratis en línea](https://r-pkgs.org/). Nuestra guía es parcialmente redundante con otros recursos, pero destaca las directrices de rOpenSci.

 Para leer por qué merece la pena enviar un paquete a rOpenSci para cumplir las directrices, echa un vistazo a [razones para enviar](#whysubmit). 

```

## Nombre del paquete y metadatos

### Cómo nombrar tu paquete

- Recomendamos encarecidamente nombres cortos y descriptivos en minúsculas. Si tu paquete tiene que ver con uno o más servicios comerciales, asegúrate de que el nombre no infringe las directrices de la marca. Puedes comprobar si el nombre de tu paquete está disponible, es informativo y no es ofensivo utilizando el botón [`disponible` paquete](https://github.com/ropenscilabs/available). En particular, no *no* elijas un nombre de paquete que ya se utilice en CRAN o en Bioconductor.

- Un nombre de paquete más único podría ser más fácil de rastrear (para que tú y nosotros evaluemos el uso del paquete) y de buscar (para que los usuarios lo encuentren y busquen en Google sus preguntas). Evidentemente, un nombre *demasiado* nombre de paquete demasiado único puede hacer que el paquete sea menos descubrible (por ejemplo, podría ser un argumento para nombrar tu paquete [geojson](https://github.com/ropensci/geojson)).

- Encuentra otros aspectos interesantes sobre cómo nombrar tu paquete [en esta entrada del blog de Nick Tierney](https://www.njtierney.com/post/2018/06/20/naming-things/)y, en caso de que cambies de opinión, descubre [cómo cambiar el nombre de tu paquete en esta otra entrada del blog de Nick](https://www.njtierney.com/post/2017/10/27/change-pkg-name/).

### Crear metadatos para tu paquete

Te recomendamos que utilices la herramienta [`codemetar` paquete](https://github.com/ropensci/codemetar) para crear y actualizar un JSON [CodeMeta](https://codemeta.github.io/) para tu paquete a través de `codemetar::write_codemeta()`. Incluirá automáticamente toda la información útil, incluyendo [Temas de GitHub](#grooming). CodeMeta utiliza [términos de Schema.org](https://schema.org/) por lo que, a medida que gane popularidad, los metadatos JSON de tu paquete podrían ser utilizados por servicios de terceros, incluso por motores de búsqueda.

## Plataformas

- Los paquetes deben funcionar en todas las plataformas principales (Windows, macOS, Linux).  Se pueden conceder excepciones a los paquetes que interactúan con funciones específicas del sistema, o envoltorios para utilidades que sólo funcionan en plataformas limitadas, pero los autores deben hacer todo lo posible para la compatibilidad entre plataformas, incluyendo la compilación específica del sistema, o la contenerización de utilidades externas.

## API del paquete

### Nombres de funciones y argumentos

- Los nombres de las funciones y los argumentos deben elegirse para que funcionen juntos y formen una API de programación común y lógica que sea fácil de leer y autocompletar.
  
  - Considera un `objeto_verbo()` para las funciones de tu paquete que toman un tipo de datos común o interactúan con una API común. `objeto` se refiere a los datos/API y `verbo` a la acción principal.  Este esquema ayuda a evitar conflictos de espacio de nombres con paquetes que pueden tener verbos similares, y hace que el código sea legible y fácil de autocompletar.  Por ejemplo, en **stringi**las funciones que empiezan por `stri_` manipulan cadenas (`stri_join()`, `stri_sort()`y en **googlesheets** las funciones que empiezan por `gs_` son llamadas a la API de Google Sheets (`gs_auth()`, `gs_user()`, `gs_descarga()`).

- Para las funciones que manipulan un objeto/dato y devuelven un objeto/dato del mismo tipo, haz que el objeto/dato sea el primer argumento de la función para mejorar la compatibilidad con el operador de tuberías (`%>%`).

- Recomendamos encarecidamente `snake_case` sobre todos los demás estilos, a menos que estés portando un paquete que ya se utiliza ampliamente.

- Evita los conflictos de nombres de funciones con los paquetes base u otros populares (por ejemplo `ggplot2`, `dplyr`, `magrittr`, `tabla.datos`)

- El nombre y el orden de los argumentos deben ser coherentes entre las funciones que utilizan inputs similares.

- Las funciones del paquete que importan datos no deben importar datos al entorno global, sino que deben devolver objetos. Las asignaciones al entorno global deben evitarse en general.

### Mensajes de la consola

- Utiliza `mensaje()` y `advertencia()` para comunicarte con el usuario en tus funciones. No utilices `print()` o `cat()` a no ser que sea para una función `print.*()` o `str.*()` ya que estos métodos de impresión de mensajes son más difíciles de suprimir para el usuario.

### Interfaces interactivas/gráficas

Si proporcionas una interfaz gráfica de usuario (GUI) (como una aplicación Shiny), para facilitar el flujo de trabajo, incluye un mecanismo para reproducir automáticamente los pasos realizados en la GUI.  Esto podría incluir la autogeneración de código para reproducir los mismos resultados, la salida de los valores intermedios producidos en la herramienta interactiva, o simplemente un mapeo claro y bien documentado entre las acciones de la GUI y las funciones con guión. (Ver también ["Pruebas"](#testing) más abajo).

El [`tabulador` paquete](https://github.com/ropensci/tabulizer) por ejemplo, tiene un flujo de trabajo interactivo para extraer tablas, pero también puede extraer sólo coordenadas, por lo que se pueden volver a ejecutar las cosas como un script. Además, dos ejemplos de aplicaciones brillantes que hacen la generación de códigos son [https://gdancik.shinyapps.io/shinyGEO/](https://gdancik.shinyapps.io/shinyGEO/)y [https://github.com/wallaceEcoMod/wallace/](https://github.com/wallaceEcoMod/wallace/).

## Estilo del código

- Para más información sobre cómo dar estilo a tu código, nombrar funciones y scripts de R dentro de `R/` te recomendamos que leas el capítulo [capítulo de código en el libro The R Packages](https://r-pkgs.org/Code.html). Recomendamos el [`styler` paquete](https://github.com/r-lib/styler) para automatizar parte de la estilización del código. Te sugerimos que leas la [Guía de estilo de Tidyverse](https://style.tidyverse.org/).

- Puedes optar por utilizar `=` sobre `<-` siempre que seas coherente con una elección dentro de tu paquete. Recomendamos evitar el uso de `->` para la asignación dentro de un paquete. Si utilizas `<-` en todo el paquete, y también utilizas `R6` en ese paquete, te verás obligado a utilizar `=` para la asignación dentro de tu `R6Clase` esto no se considera una incoherencia porque no puedes utilizar `<-` en este caso.

## Archivo CITATION

- Si tu paquete no tiene todavía un archivo CITATION, puedes crear uno con `usethis::use_citation()`y rellenarlo con los valores generados por la función `citación()` .
- Si archivas cada versión de tu repositorio de GitHub en Zenodo, añade el [DOI de nivel superior de Zenodo](https://help.zenodo.org/#versioning) al archivo CITATION.
- Si un día [**después de** la revisión en rOpenSci](#authors-guide) publicas un software sobre tu paquete, añádelo al archivo CITATION.
- Menos relacionado con tu paquete en sí, pero con lo que lo soporta: si tu paquete envuelve un recurso concreto, como una fuente de datos o, por ejemplo, un algoritmo estadístico, recuerda a los usuarios cómo citar ese recurso mediante, por ejemplo `citHeader()`. [Tal vez incluso añadas la referencia del recurso](https://discuss.ropensci.org/t/citation-of-original-article-when-implementing-specific-methods/2312).

Como ejemplo, ver [archivo nasapower CITATION](https://github.com/ropensci/nasapower/blob/master/inst/CITATION) que hace referencia tanto al manual como a un documento.
Lo único que le falta es un [DOI de Zenodo](https://discuss.ropensci.org/t/should-the-ropensci-dev-guide-include-package-citation-best-practices/1551/15) para el manual, aunque la mayoría de los usuarios probablemente acabarán citando el artículo de JOSS.

```r
citHeader("Aunque nasapower no redistribuye los datos de ninguna manera,\n
          "animamos a los usuarios a seguir las peticiones del POWER\n",
          "Equipo del proyecto:\n",
          "\n",
          "'Cuando los productos de datos del POWER se utilicen en una publicación, nosotros\n",
          "solicitamos que se incluya el siguiente reconocimiento:\n",
          "Estos datos se han obtenido del Centro de Investigación Langley de la NASA,
          "Proyecto POWER del Centro, financiado por el Programa de Ciencias de la Tierra de la NASA,
          "Programa de Ciencias Aplicadas de la Dirección",
          "\n",
          "Para citar a nasapower en las publicaciones, utiliza:")
citEntry(
  entrada = "Artículo",
  autor = as.persona("Adam H Sparks"),
  title = "nasapower: Un cliente de datos de meteorología global, energía solar superficial y climatología de NASA POWER para R",
  doi = "10.21105/joss.01035",
  año = 2018,
  mes = "oct",
  editorial = "The Open Journal",
  volumen = 3,
  número = 30,
  páginas = 1035,
  revista = "The Journal of Open Source Software",
  textVersion = paste("Sparks, Adam (2018). nasapower: A NASA POWER Global Meteorology, Surface Solar Energy and Climatology Data Client for R. Journal of Open Source Software, 3(30), 1035, https://doi.org/10.21105/joss.01035")
año <- sub("-.*", "", meta$Fecha)
nota <- sprintf("Versión del paquete R %s", meta$Versión)
bibentry(bibtype = "Manual",
         title = "{nasapower}: Datos de NASA-POWER en R",
         author = c(persona("Adam", "Sparks")),
         año = año,
         nota = nota,
	 url = "https://CRAN.R-project.org/package=nasapower")
 textVersion = paste0("Adam H Sparks, (", año, "),
  " nasapower: Un cliente de datos de meteorología global, energía solar superficial y climatología de NASA POWER para R. ",
  nota, ".",
  ", https://CRAN.R-project.org/package=nasapower")
```

- También puedes crear y almacenar un archivo `CITACIÓN.cff` gracias al paquete [paquete cffr](https://docs.ropensci.org/cffr/). También proporciona un [flujo de trabajo de la Acción GitHub](https://docs.ropensci.org/cffr/reference/cff_gha_update.html) para mantener la `CITACIÓN.cff` actualizado.

## README

- Todos los paquetes deben tener un archivo README, llamado `README.md`en la raíz del repositorio. El README debe incluir, de arriba a abajo
  
  - El nombre del paquete.
  - Insignias para la integración continua y la cobertura de pruebas, la insignia para la revisión por pares de rOpenSci una vez que haya comenzado (ver más abajo), una insignia de repostatus.org, y cualquier otra insignia (por ejemplo [R-universo](https://ropensci.org/blog/2021/10/14/runiverse-badges/)). Si el README tiene muchas más insignias, puedes considerar el uso de una tabla de insignias, ver [este ejemplo](https://github.com/ropensci/ijtiff#ijtiff-), [este otro](https://github.com/ropensci/drake) y [ese otro](https://github.com/ropensci/qualtRics/). Esta tabla debe ser más ancha que alta.
  - Breve descripción de los objetivos del paquete, con enlaces descriptivos a todas las viñetas (renderizadas, es decir, legibles, cf. [la sección de la web de documentación](#website)) a menos que el paquete sea pequeño y sólo haya una viñeta que repita el LÉAME.
  - Instrucciones de instalación utilizando, por ejemplo, el paquete [paquete remotes](https://remotes.r-lib.org/), [paquete pak](https://pak.r-lib.org/)o [R-universo](https://ropensci.org/blog/2021/06/22/setup-runiverse/).
  - Cualquier configuración adicional que se requiera (tokens de autenticación, etc).
  - Breve demostración de uso.
  - Si procede, cómo se compara el paquete con otros paquetes similares y/o cómo se relaciona con otros paquetes.
  - Información sobre la citación, es decir, dirige a los usuarios a la cita preferida en el LÉAME añadiendo el texto "así es como se puede citar mi paquete". Véase, por ejemplo [ecmwfr LÉAME](https://github.com/bluegreen-labs/ecmwfr#how-to-cite-this-package-in-your-article).

Si utilizas otro distintivo de estado del repo, como un [ciclo de vida](https://www.tidyverse.org/lifecycle/) por favor, añade también un [repostatus.org](https://www.repostatus.org/) . [Ejemplo de un README del repo con dos insignias de estado del repo](https://github.com/ropensci/ijtiff#ijtiff-).

- Una vez que hayas enviado un paquete y haya pasado las comprobaciones del editor, añade una insignia de revisión por pares a través de

```
[![](https://badges.ropensci.org/<issue_id>_status.svg)](https://github.com/ropensci/software-review/issues/<issue_id>)
```

donde issue\_id es el número de la cuestión en el repositorio de revisión de software. Por ejemplo, la insignia de [`rtimicropem`](https://github.com/ropensci/rtimicropem) utiliza el número 126, ya que es el número de [número de incidencia de la revisión](https://github.com/ropensci/software-review/issues/126). La insignia indicará primero "en revisión" y luego "revisado por pares" una vez que tu paquete haya sido incorporado (número etiquetado como "aprobado" y cerrado), y enlazará con el número de revisión.

- Si tu README tiene muchas insignias, considera la posibilidad de ordenarlas en una tabla html para facilitar a los recién llegados la obtención de información de un vistazo. Consulta los ejemplos en [`drake` repo](https://github.com/ropensci/drake) y en [`qualtRics` repo](https://github.com/ropensci/qualtRics/). Las secciones posibles son
  
  - Desarrollo (estados CI cf [capítulo CI](#ci)canal de Slack para la discusión, repostatus)
  - Liberación/Publicación ([Insignias de la versión de CRAN y de la fecha de publicación de METACRAN](https://www.r-pkg.org/services#badges), [Insignia de la API de comprobación de CRAN](https://github.com/ropensci/cchecksapi#badges), insignia de Zenodo)
  - Estadísticas/Uso (descargas, por ejemplo [insignias de descarga de METACRAN](https://www.r-pkg.org/services#badges))
    La tabla debe ser más ancha que larga para enmascarar el resto del LÉAME.

- Si tu paquete se conecta a una fuente de datos o a un servicio en línea, o envuelve otro software, ten en cuenta que el LÉEME de tu paquete puede ser el primer punto de entrada para los usuarios.  Debe proporcionar suficiente información para que los usuarios entiendan la naturaleza de los datos, el servicio o el software, y proporcionar enlaces a otros datos y documentación relevantes.  Por ejemplo
  un LÉEME no debe limitarse a decir: "Proporciona acceso a GooberDB", sino que también debe incluir
  "..., un repositorio online de avistamientos de Goober en Sudamérica.  Más información en
  información sobre GooberDB, y la documentación de la estructura de la base de datos y los metadatos
  pueden encontrarse en *enlace*".

- Recomendamos no crear `README.md` directamente, sino a partir de un `README.Rmd` (un archivo R Markdown) si tienes algún código de demostración. La ventaja del archivo `.Rmd` es que puedes combinar texto con código que puede actualizarse fácilmente cada vez que se actualice tu paquete.

- Considera la posibilidad de utilizar `usethis::use_readme_rmd()` para obtener una plantilla para un `README.Rmd` y configurar automáticamente un gancho de precompromiso para garantizar que el archivo `README.md` sea siempre más reciente que `README.Rmd`.

- Los ejemplos extensos deben guardarse para una viñeta. Si quieres que las viñetas sean más accesibles antes de instalar el paquete, te sugerimos [crear un sitio web para tu paquete](#website).

- Añade un [código de conducta y directrices de contribución](#friendlyfiles).

- Consulta el [`gistr` README](https://github.com/ropensci/gistr#gistr) para un buen ejemplo de README a seguir para un paquete pequeño, y [`bowerbird` README](https://github.com/ropensci/bowerbird) para un buen ejemplo de README para un paquete más grande.

## Documentación

### General

- Todas las funciones exportadas del paquete deben estar completamente documentadas con ejemplos.

- Si existe un posible solapamiento o confusión con otros paquetes que ofrezcan una funcionalidad similar o tengan un nombre parecido, añade una nota en el LÉAME, en la viñeta principal y, potencialmente, en el campo Descripción de DESCRIPTION. Ejemplo en [rtweet README](https://docs.ropensci.org/rtweet/), [rebird README](https://docs.ropensci.org/rebird/#auk-vs-rebird).

- El paquete debe contener la documentación de nivel superior para `foobar`(o `paquete-fobar ` si hay un conflicto de nombres). Opcionalmente, puedes utilizar tanto `?foobar` y ```foobar-paquete` `` para el archivo de manual a nivel de paquete, utilizando `@aliases` etiqueta roxygen. `usethis::use_package_doc()` añade la plantilla para la documentación de nivel superior.

- El paquete debe contener al menos un **HTML** que proporcione una cobertura sustancial de las funciones del paquete, ilustrando casos de uso realistas y cómo se pretende que interactúen las funciones. Si el paquete es pequeño, la viñeta y el README pueden tener un contenido muy similar.

- Al igual que el LÉAME, la documentación de primer nivel o las viñetas pueden ser el primer punto de entrada para los usuarios. Si tu paquete se conecta a una fuente de datos o a un servicio en línea, o envuelve otro software, debe proporcionar suficiente información para que los usuarios entiendan la naturaleza de los datos, el servicio o el software, y proporcionar enlaces a otros datos y documentación relevantes.  Por ejemplo, la introducción de una viñeta o la documentación no debería limitarse a decir: "Proporciona acceso a GooberDB", sino incluir también: "..., un repositorio online de avistamientos de Goober en Sudamérica".  Puedes encontrar más información sobre GooberDB y la documentación de la estructura de la base de datos y los metadatos en *enlace*". Cualquier viñeta debe exponer los conocimientos previos para poder entender la viñeta de antemano.

La viñeta general debe presentar una serie de ejemplos que progresen en complejidad desde el uso básico al avanzado.

- La funcionalidad que probablemente sólo utilicen los usuarios más avanzados o los desarrolladores podría estar mejor en una viñeta separada (por ejemplo, la programación de NSE con dplyr).

- El LÉAME, la documentación del paquete de nivel superior, las viñetas, los sitios web, etc., deben tener suficiente información al principio para obtener una visión general de alto nivel del paquete y de los servicios/datos a los que se conecta, y proporcionar navegación a otras piezas de documentación relevantes. Esto es para seguir el principio de *múltiples puntos de entrada* es decir, tener en cuenta el hecho de que cualquier pieza de documentación puede ser el primer encuentro del usuario con el paquete y/o la herramienta/datos que envuelve.

- La(s) viñeta(s) debe(n) incluir citas del software y de los documentos cuando sea apropiado.

- Si tu paquete proporciona acceso a una fuente de datos, requerimos que la DESCRIPCIÓN contenga (1) Una breve identificación y/o descripción de la organización responsable de la emisión de los datos; y (2) La URL que enlaza con la página pública que proporciona, describe o permite el acceso a los datos (que a menudo puede diferir de la URL que conduce directamente a la fuente de datos).

- Utiliza los mensajes de inicio del paquete sólo cuando sea necesario (enmascaramiento de funciones, por ejemplo). Evita los mensajes de inicio del paquete como "Esto es foobar 2.4-0" o la guía de citación porque pueden ser molestos para el usuario. Apóyate en la documentación para obtener dicha orientación.

- Puedes optar por tener una sección README sobre casos de uso de tu paquete (otros paquetes, entradas de blog, etc.), [ejemplo](https://github.com/ropensci/vcr#example-packages-using-vcr).

### uso de roxygen2

- Pedimos que todos los envíos utilicen `roxygen2` para la documentación.  `roxygen2` es [un paquete de R](https://cran.r-project.org/web/packages/roxygen2/index.html) que compila automáticamente los archivos `.Rd` a sus archivos `man` de tu paquete a partir de simples etiquetas escritas sobre cada función.

- Más información sobre el uso de roxygen2 [documentación](https://r-pkgs.org/man.html) está disponible en el libro de paquetes de R.

- Si escribieras Rd a mano, el programa [Rd2roxygen](https://cran.r-project.org/web/packages/Rd2roxygen/index.html) contiene funciones para convertir la documentación de Rd en roxygen.

- Una ventaja clave de utilizar `roxygen2` es que tu `NAMESPACE` siempre se generará automáticamente y estará actualizado.

- Todas las funciones deben documentar el tipo de objeto devuelto en el campo `@retorno` de la función.

- El valor por defecto de cada parámetro debe estar claramente documentado. Por ejemplo, en lugar de escribir `Un valor lógico que determina si ...`deberías escribir ``Un valor lógico (por defecto `TRUE`) que determina si ...``. También es una buena práctica indicar los valores por defecto directamente en la definición de tu función:

```{r, eval=FALSE}
f <- function(a = TRUE) {
  # código de la función
}
```

- La documentación debe apoyar la navegación del usuario incluyendo enlaces cruzados útiles entre funciones relacionadas y documentando funciones relacionadas juntas en grupos o en páginas de ayuda comunes.  El `@seealso` y `@familia` (esta última crea automáticamente enlaces "Ver también" y [puede ayudar a agrupar](https://pkgdown.r-lib.org/reference/build_reference.html) funciones en los sitios de pkgdown), se recomiendan para este fin. Consulta [la sección "manual" del libro The R Packages](https://r-pkgs.org/man.html) y [la sección "agrupación de funciones" del presente capítulo](#function-grouping) para más detalles.

- Podrías reutilizar piezas de documentación (por ejemplo, detalles sobre la autenticación, paquetes relacionados) en las viñetas/README/páginas de manual. Un posible enfoque para ello es el uso de [fragmentos de R Markdown, confiando en el uso de knitr de los documentos hijos para que puedas almacenar las partes reutilizadas en una carpeta en man/, y llamarlas tanto desde el README como desde la viñeta](https://www.garrickadenbuie.com/blog/dry-vignette-and-readme/) como desde [como en las páginas man, utilizando la función `@includeRmd` disponible en `roxygen 0.7.0`](https://roxygen2.r-lib.org/articles/rd.html#including-external--rmd-md-files).

- Añade `#@noRd` a las funciones internas.

- Si prefieres no abarrotar el código con una extensa documentación, puedes colocar más ejemplos fuera del script de R y utilizar el `@ejemplo` y colocar más documentación en archivos de `man-roxygen` en la raíz de tu paquete, y éstos se combinarán en el archivo de manual mediante el uso de `@plantilla <nombre del archivo>`por ejemplo.
  
  - Coloca cualquier documentación de un objeto en un archivo `.R` en el archivo `man-roxygen` (en la raíz de tu paquete). Por ejemplo [este archivo](https://github.com/ropensci/rgbif/blob/master/man-roxygen/occ_search_egs.R). Enlaza con ese archivo de plantilla desde tu función ([por ejemplo](https://github.com/ropensci/rgbif/blob/master/R/occ_search.r)) con el botón `@plantilla` ([por ejemplo](https://github.com/ropensci/rgbif/blob/master/R/occ_search.r#L7)). El contenido de la plantilla se insertará cuando se construya la documentación en el archivo `.Rd` que los usuarios verán cuando pidan la documentación de la función.
  - Ten en cuenta que si utilizas documentación en markdown, éste no funciona actualmente en los archivos de plantilla, así que asegúrate de utilizar el formato latex.
  - En la mayoría de los casos puedes ignorar las plantillas y el `man-roxygen`pero hay dos casos en los que aprovecharlos será de gran ayuda:
    1. Cuando tengas mucha documentación para una función/clase/objeto, separar ciertos trozos de esa documentación puede mantener tu `.R` ordenado. Esto es especialmente útil cuando tienes mucho código en ese archivo `.R` . Por otro lado, significa que la documentación no es legible "en el código fuente", ya que está en otro archivo.
    2. Cuando tienes las mismas partes de documentación utilizadas en muchos archivos `.R` es útil utilizar una plantilla. Esto reduce el texto duplicado y ayuda a evitar que se actualice por error la documentación de una función pero no la de otra. Utilizar un archivo de plantilla para la documentación de un parámetro es una alternativa a definir el parámetro para una función y utilizar `@inheritParámetros` para otras funciones que utilicen el mismo parámetro.

- A partir de `roxygen2` versión 7.0.0, `R6` están oficialmente soportadas. Consulta la documentación de [roxygen2 docs](https://roxygen2.r-lib.org/articles/rd.html#r6) para saber cómo documentar `R6` de las clases.

### URLs en la documentación

Esta subsección es especialmente relevante para los autores que deseen enviar su paquete a CRAN.
CRAN comprobará las URLs en tu documentación y no permite códigos de estado de redirección como 301.
Puedes utilizar el [urlchecker](https://github.com/r-lib/urlchecker) para reproducir estas comprobaciones y, en particular, sustituir las URLs por las URLs a las que redirigen.
Otros han utilizado la opción de escapar de algunas URLs (cambiar `<https://ropensci.org/>` por `https://ropensci.org/`o `\url{https://ropensci.org/}` a `https://ropensci.org/`.), pero si lo haces, tendrás que implementar tú mismo algún tipo de comprobación de URL para evitar que se rompan sin que te des cuenta. Además, los enlaces no se podrán pulsar desde la documentación local.

## Sitio web de documentación {#website}

Te recomendamos que crees un sitio web de documentación para tu paquete utilizando [`pkgdown`](https://github.com/r-lib/pkgdown). Neal Richardson escribió [un buen tutorial para empezar con `pkgdown`](https://enpiar.com/2017/11/21/getting-down-with-pkgdown/)y como es lógico `pkgdown` tiene [su propio sitio web de documentación](https://pkgdown.r-lib.org/).

Hay algunos elementos que nos gustaría subrayar aquí.

### Despliegue automático del sitio web de documentación {#docsropensci}

Sólo tienes que preocuparte del despliegue automático de tu sitio web hasta la aprobación y la transferencia de tu repo de paquetes a la organización ropensci; de hecho, después de eso se construirá un sitio web pkgdown para tu paquete después de cada empuje al repo de GitHub. Puedes encontrar el estado de estas construcciones en `https://dev.ropensci.org/job/package_name`por ejemplo [para `magick`](https://dev.ropensci.org/job/magick)y el sitio web en `https://docs.ropensci.org/package_name`por ejemplo [para `magick`](https://docs.ropensci.org/magick). La construcción del sitio web utilizará tu archivo de configuración pkgdown si tienes uno, excepto el estilo que utilizará el [`rotemplate` paquete](https://github.com/ropensci-org/rotemplate/). El sitio web resultante tendrá una barra de búsqueda local. Por favor, informa de los errores, preguntas y peticiones de características sobre las construcciones centrales en [https://github.com/ropensci/docs/](https://github.com/ropensci/docs/) y sobre la plantilla en [https://github.com/ropensci/rotemplate/](https://github.com/ropensci/rotemplate/).

*Si las viñetas de tus paquetes necesitan credenciales (claves de la API, tokens, etc.) para poder tejerse, es posible que quieras [precalcularlas](https://ropensci.org/technotes/2019/12/08/precompute-vignettes/) ya que las credenciales no se pueden utilizar en el servidor de docs.*

Antes del envío y de la transferencia, podrías utilizar el [enfoque documentado por `pkgdown`](https://pkgdown.r-lib.org/reference/deploy_site_github.html) o el método [`tic` paquete](https://docs.ropensci.org/tic/) para el despliegue automático del sitio web del paquete. Esto te ahorraría la molestia de ejecutar (y recordar ejecutar) `pkgdown::build_site()` cada vez que sea necesario actualizar el sitio. Primero consulta nuestro [capítulo sobre integración continua](#ci) si no estás familiarizado con la integración continua. En cualquier caso, no olvides actualizar todas las apariciones de la URL del sitio web después de la transferencia a la organización ropensci.

### Agrupar funciones en la referencia {#function-grouping}

Cuando tu paquete tenga muchas funciones, utiliza la agrupación en la referencia, que puedes hacer de forma más o menos automática.

Si utilizas `roxygen2` por encima de la versión 6.1.1, debes utilizar la función `@familia` en la documentación de tus funciones para indicar la agrupación. Esto te dará enlaces entre las funciones en la documentación local del paquete instalado (sección "Ver también") *y* te permitirá utilizar la etiqueta `pkgdown` `tiene_concepto` en el archivo de configuración de tu sitio web. Ejemplo de no-rOpenSci por cortesía de [`optiRum`](https://github.com/lockedata/optiRum): [etiqueta familiar](https://github.com/lockedata/optiRum/blob/master/R/APR.R#L17), [`pkgdown` archivo de configuración](https://github.com/lockedata/optiRum/blob/master/_pkgdown.yml) y [sección de referencia resultante](https://itsalocke.com/optirum/reference/).
Para personalizar el texto del título de la referencia cruzada creada por roxygen2 (`Otra {familia}:`), consulta la documentación de [docs de roxygen2 sobre cómo proporcionar un `rd_family_title` en `man/roxygen/meta.R`](https://roxygen2.r-lib.org/articles/rd.html#cross-references).

De forma menos automática, consulta el ejemplo de [`drake` sitio web](https://docs.ropensci.org/drake/) y [archivo de configuración asociado
](https://github.com/ropensci/drake/blob/master/_pkgdown.yml).

### Marca de los autores

Puedes hacer que los nombres de (algunos) autores sean clicables añadiendo su URL, e incluso puedes sustituir sus nombres por un logotipo (piensa en rOpenSci... ¡o en tu organización/empresa!). Ver [`pkgdown` documentación](https://pkgdown.r-lib.org/reference/build_home.html?q=authors#yaml-config-authors).

### Ajustar la barra de navegación

Puedes hacer que el contenido de tu sitio web sea más fácil de navegar ajustando la barra de navegación, consulta [`pkgdown` documentación](https://pkgdown.r-lib.org/articles/pkgdown.html#navigation-bar). En particular, ten en cuenta que si nombras la viñeta principal de tu paquete "pkg-name.Rmd", será accesible desde la navbar como `Inicio` en lugar de a través de `Artículos > Título de la viñeta`.

### Mathjax

Una vez que tu paquete sea transferido y obtenga un sitio web usando nuestro `pkgdown` si quieres utilizar Mathjax, tendrás que especificarlo en la plantilla `pkgdown` como se indica a continuación:

```yaml
template:
  params:
    mathjax: true
```

### Logotipo del paquete

Para utilizar el logotipo de tu paquete en la página de inicio de pkgdown, consulta [`usethis::use_logo()`](https://usethis.r-lib.org/reference/use_logo.html).
Si tu paquete no tiene ningún logotipo, el [rOpenSci docs builder](#docsropensci) utilizará el logotipo de rOpenSci en su lugar.

## Autoría {#autoría}

El `DESCRIPCIÓN` de un paquete debe listar los autores y colaboradores de un paquete, utilizando la etiqueta `Autores@R` para indicar sus funciones (autor/creador/colaborador, etc.) si hay más de un autor, y utilizando el campo de comentarios para indicar el ID ORCID de cada autor, si lo tiene (véase [este post](https://ropensci.org/technotes/2018/10/08/orcid/)). Véase [esta sección de "Escribir extensiones de R"](https://cran.rstudio.com/doc/manuals/r-release/R-exts.html#The-DESCRIPTION-file) para más detalles.  Si crees que tus revisores han hecho una contribución sustancial al desarrollo de tu paquete, puedes incluirlos en la lista `Autores@R` con un tipo de contribución de revisor (`"rev"`), así:

```
    persona("Bea", "Hernández", rol = "rev",
    comentario = "Bea revisó el paquete (v. X.X.XX) para rOpenSci, ver <https://github.com/ropensci/software-review/issues/116>"),
```

Sólo incluye a los revisores después de pedirles su consentimiento. Lee más en [esta entrada del blog "Agradeciendo a tus revisores: La gratitud a través de los metadatos semánticos"](https://ropensci.org/blog/2018/03/16/thanking-reviewers-in-metadata/). Por favor, no incluyas a los editores como colaboradores. ¡Su participación y contribución a rOpenSci es suficiente agradecimiento!

### Autoría del código incluido {#authorship-included-code}

Muchos paquetes incluyen código de otro software. Tanto si se incluyen archivos enteros como funciones individuales de otros paquetes, los paquetes de rOpenSci deben seguir [el CRAN *Política del repositorio*](https://cran.r-project.org/web/packages/policies.html):

> La titularidad de los derechos de autor y de propiedad intelectual de todos los componentes del paquete debe ser clara e inequívoca (incluso a partir de la especificación de los autores en el archivo DESCRIPTION). Cuando el código se copie (o se derive) del trabajo de otros (incluso del propio R), hay que tener cuidado de que se conserve cualquier declaración de derechos de autor/licencia y que no se tergiverse la autoría.
> 
> Preferiblemente, se utilizaría un campo "Autores@R" con funciones "ctb" para los autores de dicho código. Como alternativa, el campo "Autor" debería incluir a estos autores como colaboradores.
> 
> Cuando los derechos de autor los tenga una entidad distinta de los autores del paquete, se indicará preferentemente mediante roles "cph" en el campo "Autores@R", o utilizando un campo "Derechos de autor" (si es necesario, haciendo referencia a un archivo inst/COPYRIGHTS).
> 
> Deben respetarse las marcas comerciales.

## Licencia

El paquete debe tener una licencia [CRAN](https://svn.r-project.org/R/trunk/share/licenses/license.db) o [OSI](https://opensource.org/licenses) aceptada.
Para más explicaciones sobre las licencias, consulta el [Libro de paquetes de R](https://r-pkgs.org/license.html).

## Probando

- Todos los paquetes deben pasar la `Comprobación del CMD de R`/`devtools::check()` en las principales plataformas.

- Todos los paquetes deben tener un conjunto de pruebas que cubran la funcionalidad principal del paquete. Las pruebas también deberían cubrir el comportamiento del paquete en caso de errores.

- Es una buena práctica escribir pruebas unitarias para todas las funciones, y para todo el código del paquete en general, asegurando que se cubra la funcionalidad clave. La cobertura de las pruebas por debajo del 75% probablemente requerirá pruebas adicionales o una explicación antes de ser enviada para su revisión.

- Recomendamos utilizar [testthat](https://testthat.r-lib.org/) para escribir las pruebas. Esfuérzate por escribir pruebas a medida que escribes cada nueva función. Esto responde a la necesidad obvia de tener pruebas adecuadas para el paquete, pero te permite pensar en varias formas en las que una función puede fallar, y en *defensivamente* defensivamente contra ellas. [Más información](https://r-pkgs.org/tests.html).

- Las pruebas deben ser fáciles de entender. Te sugerimos que leas la entrada del blog [*"Por qué los buenos desarrolladores escriben malas pruebas unitarias"*](https://mtlynch.io/good-developers-bad-tests/) de Michael Lynch.

- Los paquetes con aplicaciones Shiny deberían utilizar un marco de pruebas unitarias como [`shinytest`](https://rstudio.github.io/shinytest/articles/shinytest.html) para comprobar que las interfaces interactivas se comportan como se espera.

- Para probar las funciones que crean gráficos, sugerimos utilizar [vdiffr](https://cran.rstudio.com/web/packages/vdiffr/index.html)una extensión del paquete testthat; o [pruebas de instantáneas de testthat](https://testthat.r-lib.org/articles/snapshotting.html).

- Si tu paquete interactúa con recursos de la web (APIs de la web y otras fuentes de datos en la web) puedes encontrar el libro [libro HTTP testing in R de Scott Chamberlain y Maëlle Salmon](https://books.ropensci.org/http-testing/) relevante. Paquetes que ayudan a realizar pruebas HTTP (clientes HTTP correspondientes):
  
  - [httptest2](https://enpiar.com/httptest2/) ([httr2](https://httr2.r-lib.org/));
  - [httptest](https://enpiar.com/r/httptest/) ([httr](https://httr.r-lib.org/));
  - [vcr](https://docs.ropensci.org/vcr/) ([httr](https://httr.r-lib.org/), [crul](https://docs.ropensci.org/crul));
  - [webfakes](https://webfakes.r-lib.org/) ([httr](https://httr.r-lib.org/), [httr2](https://httr2.r-lib.org/), [crul](https://docs.ropensci.org/crul), [curl](https://github.com/jeroen/curl)).

- testthat tiene una función `skip_on_cran()` que puedes utilizar para no ejecutar las pruebas en CRAN. Recomendamos utilizarla en todas las funciones que sean llamadas a la API, ya que es muy probable que fallen en CRAN. Estas pruebas deberían seguir ejecutándose en integración continua. Ten en cuenta que a partir de testthat 3.1.2 `skip_if_offline()` llama automáticamente a `skip_on_cran()`. Más información sobre [Preparación de CRAN para las envolturas de la API](https://books.ropensci.org/http-testing/cran-preparedness.html).

- Si tu paquete interactúa con una base de datos puedes encontrar [dittodb](https://docs.ropensci.org/dittodb) útil.

- Una vez que hayas configurado [la integración continua (CI)](#ci)utiliza el informe de cobertura de código de tu paquete (véase [esta sección de nuestro libro](#coverage)) para identificar las líneas no probadas y añadir más pruebas.

- Aunque utilices la [integración continua](#ci)te recomendamos que ejecutes las pruebas localmente antes de enviar tu paquete, ya que algunas pruebas suelen omitirse (es posible que tengas que configurar `Sys.setenv(NOT_CRAN="true")` para asegurarte de que se ejecutan todas las pruebas). Además, te recomendamos que, antes de enviar tu paquete, utilices el programa de MangoTheCat [**buenas prácticas**](https://github.com/MangoTheCat/goodpractice/) para comprobar que tu paquete no contenga fuentes de error, y que ejecutes `spelling::spell_check_package()` para encontrar errores ortográficos en la documentación.

## Ejemplos

- Incluye ejemplos extensos en la documentación. Además de demostrar cómo se utiliza el paquete, pueden ser una forma fácil de probar la funcionalidad del paquete antes de que haya pruebas adecuadas. Sin embargo, ten en cuenta que exigimos pruebas en los paquetes contribuidos.

- Puedes ejecutar los ejemplos con `devtools::run_examples()`. Ten en cuenta que cuando ejecutes R CMD CHECK o su equivalente (por ejemplo `devtools::check()`) tus ejemplos que no están envueltos en `\ón{}` o `\donttest{}` se ejecutan. Consulta la [tabla resumen](https://roxygen2.r-lib.org/articles/rd.html#functions) en la documentación de roxygen2.

- Para proteger los ejemplos (por ejemplo, requiriendo autenticación) para que se ejecuten en CRAN, tienes que utilizar `|dontrun{}`. Sin embargo, para un primer envío, CRAN no te permitirá tener todos los ejemplos escapados así. En este caso, puedes añadir algunos pequeños ejemplos de juguete, o envolver el código del ejemplo en `try()`. También puedes consultar el `@ejemploIf` presente, en el momento de escribir este artículo, en la versión de desarrollo de roxygen2.

- Además de ejecutar los ejemplos localmente en tu propio ordenador, te aconsejamos encarecidamente que ejecutes los ejemplos en uno de los [sistemas de integración continua](#ci). De nuevo, los ejemplos que no estén envueltos en `\dontrun{}` o `\donttest{}` se ejecutarán, pero para los que sí lo están puedes configurar tus construcciones de integración continua para que se ejecuten mediante los argumentos de comprobación de R CMD `--run-dontrun` y/o `--run-donttest`.

## Dependencias del paquete {#pkgdependencies}

- Utiliza `Importaciones` en lugar de `Depende` para los paquetes que proporcionan funciones de otros paquetes. Asegúrate de enumerar los paquetes utilizados para las pruebas (`prueba que`), y la documentación (`knitr`, `roxygen2`) en tus `Sugiere` de las dependencias de los paquetes (si utilizas `utiliza este` para añadir la infraestructura de pruebas mediante [`usethis::use_testthat()`](https://usethis.r-lib.org/reference/use_testthat.html) o una viñeta mediante [usethis::use\_vignette()](https://usethis.r-lib.org/reference/use_vignette.html)los paquetes necesarios se añadirán a `DESCRIPTION`). Si utilizas algún paquete en los ejemplos o pruebas de tu paquete, asegúrate de listarlo en `Sugerencias`si no aparece ya en `Importaciones`.

- Si tu paquete (no de Bioconductor) depende de paquetes de Bioconductor, asegúrate de que las instrucciones de instalación en el LÉAME y la viñeta son lo suficientemente claras incluso para un usuario que no esté familiarizado con el ciclo de publicación de Bioconductor.
  
  - Si el usuario utiliza [`BiocManager`](https://www.bioconductor.org/install/index.html#why-biocmanagerinstall) (recomendado)? Documenta esto.
  
  - ¿La instalación automática de los paquetes de Bioconductor mediante `install.packages()` es suficiente? En ese caso, menciona que el usuario debe ejecutar `setRepositories()` si aún no ha configurado los repositorios de Bioconductor necesarios.
  
  - Si tu paquete depende de Bioconductor a partir de una determinada versión, menciónalo en DESCRIPTION y en las instrucciones de instalación.

- Especificar las dependencias mínimas (por ejemplo `glue (>= 1.3.0)` en lugar de sólo `glue`) debería ser una elección consciente. Si sabes con certeza que tu paquete se romperá por debajo de una determinada versión de dependencia, especifícala explícitamente.
  Pero si no lo sabes, no es necesario especificar una dependencia mínima. En ese caso, si un usuario informa de un fallo que está explícitamente relacionado con una versión más antigua de una dependencia, entonces atiéndelo.
  Un ejemplo de mala práctica sería que un desarrollador considerara las versiones de su estado actual de dependencias como la versión mínima. Eso obligaría innecesariamente a todo el mundo a actualizarse (causando problemas con otros paquetes) cuando no hay una buena razón detrás de esa elección de versión.

- En la mayoría de los casos en los que debas exponer al usuario funciones de las dependencias, deberías importar y reexportar esas funciones individuales en lugar de enumerarlas en el archivo `Dependencias` .  Por ejemplo, si las funciones de tu paquete producen `raster` podrías reexportar sólo las funciones de impresión y trazado del paquete **raster** del paquete raster.

- Si tu paquete utiliza un *sistema* del sistema, debes
  
  - Indicarla en la DESCRIPCIÓN;
  
  - Comprobar que aparece en la lista de [`sysreqsdb`](https://github.com/r-hub/sysreqsdb#sysreqs) para permitir que las herramientas automáticas lo instalen, y [enviar una contribución](https://github.com/r-hub/sysreqsdb#contributing) si no es así;
  
  - Comprueba si está en un `configure` ([ejemplo](https://github.com/ropensci/magick/blob/c116b2b8505f491db72a139b61cd543b7a2ce873/DESCRIPTION#L19)) y dar un mensaje de error útil si no se encuentra ([ejemplo](https://github.com/cran/webp/blob/master/configure)).
    `configurar` pueden ser un reto, ya que a menudo requieren soluciones complicadas
    para hacer que diversas dependencias del sistema funcionen en todos los sistemas. Utiliza ejemplos ([más aquí](https://github.com/search?q=org%3Acran+anticonf&type=Code)) como punto de partida, pero ten en cuenta que es habitual encontrar errores y casos límite y que a menudo se violan las políticas de CRAN. No dudes en [pedir ayuda en nuestro foro](https://discuss.ropensci.org/).

- Ten en cuenta las ventajas y desventajas de depender de un paquete. Por un lado
  el uso de dependencias reduce el esfuerzo de codificación, y puede basarse en una funcionalidad útil desarrollada por
  otros, especialmente si la dependencia realiza tareas complejas, es de alto rendimiento
  y/o está bien revisada y probada. Por otro lado, tener muchas dependencias
  supone una carga para el mantenedor, que debe estar al día de los cambios en esos paquetes, con riesgo
  para la sostenibilidad de tu paquete a largo plazo.  También
  aumenta el tiempo y el tamaño de la instalación, lo que supone principalmente una consideración en tu ciclo de desarrollo y en el de otros, y en los sistemas de compilación automatizados. Los paquetes "pesados" -los que tienen muchas dependencias en sí mismos, y los que tienen grandes cantidades de código compilado- aumentan este coste. He aquí algunos enfoques para reducir
  las dependencias:
  
  - Las funciones pequeñas y sencillas de un paquete dependiente pueden copiarse mejor en
    tu propio paquete si la dependencia si sólo utilizas unas pocas funciones
    en una dependencia grande o pesada.  (Ver [*Autoría* sección
    arriba](#authorship-included-code) para saber cómo reconocer a los autores originales
    del código copiado). Por otro lado, las funciones complejas con muchos casos
    (por ejemplo, los analizadores sintácticos) requieren considerables pruebas y revisiones.
    
    - Un ejemplo común de esto es la devolución de "tibbles" al estilo de tidyverse de las funciones del paquete
      que proporcionan datos.
      Se puede evitar el modesto y pesado **tibble** devolviendo
      un tibble creado modificando un marco de datos de la siguiente manera
      
      ```
      class(df) <- c("tbl_df", "tbl", "data.frame") 
      ```
      
      (Ten en cuenta que este enfoque [no está universalmente respaldado](https://twitter.com/krlmlr/status/1067856118385381377).)
  
  - Asegúrate de que utilizas el paquete donde está definida la función
    y no uno en el que se reexporte. Por ejemplo, muchas funciones de **devtools** pueden encontrarse en paquetes especializados más pequeños, como **sessioninfo**. El sitio web `%>%` función
    debe ser importada de **magrittr**donde está definida, en lugar de la más pesada
    **dplyr**que la reexporta.
  
  - Se prefieren algunas dependencias porque proporcionan nombres de funciones y sintaxis más fáciles de interpretar
    los nombres de las funciones y la sintaxis que las soluciones de R base. Si ésta es la razón principal
    razón para utilizar una función en una dependencia pesada, considera envolver
    el enfoque de R base en una función interna bien nombrada en tu paquete. Consulta, por ejemplo, el [rlang R script que proporciona funciones con una sintaxis similar a las funciones purrr](https://github.com/r-lib/rlang/blob/master/R/compat-purrr.R).
  
  - Si las dependencias tienen funcionalidades que se solapan, comprueba si puedes confiar en una sola.
  
  - Puedes encontrar más consejos sobre la gestión de dependencias [en este post de
    Scott Chamberlain](https://recology.info/2018/10/limiting-dependencies/).

## Andamiaje recomendado

- Para las peticiones HTTP recomendamos utilizar [curl][curl], [crul][crul], [httr][httr] o [httr2][httr2] sobre [RCurl][RCurl]. Si te gustan los clientes de bajo nivel para HTTP [curl][curl] es mejor, mientras que [crul][crul] o [httr][httr] son mejores para un acceso de mayor nivel. [crul][crul] es mantenido por rOpenSci. Recomendamos los paquetes mantenidos por rOpenSci [webmockr][webmockr] para imitar las peticiones HTTP, y [vcr][vcr] para almacenar en caché las peticiones HTTP en las pruebas del paquete.

- Para segmentar JSON, utiliza [jsonlite][jsonlite] en lugar de [rjson][rjson] o [RJSONIO][RJSONIO].

- Para segmentar, crear y manipular XML, recomendamos encarecidamente [xml2][xml2] para la mayoría de los casos. [Puedes consultar las notas de Daniel Nüst sobre la migración de XML a xml2](https://gist.github.com/nuest/3ed3b0057713eb4f4d75d11bb62f2d66).

- Para los datos espaciales, el [sp][sp] debe considerarse obsoleto en favor de [sf][sf]y los paquetes [rgdal][rgdal], [maptools][maptools]y [rgeos][rgeos] se retirarán a finales de 2023. Recomendamos el uso de las suites espaciales desarrolladas por el [r-spatial](https://github.com/r-spatial) y [rspatial](https://github.com/rspatial) y rspatial. Consulta en [este tema de GitHub](https://github.com/ropensci/software-review-meta/issues/47) para ver las discusiones pertinentes.

## Control de versiones

- Los archivos fuente de tu paquete tienen que estar bajo control de versiones, más concretamente rastreados con [Git](https://happygitwithr.com/). Puede que encuentres el [paquete gert](https://docs.ropensci.org/gert/) relevante, así como algunas de las [funcionalidad relacionada con Git/GitHub](https://usethis.r-lib.org/reference/index.html#section-git-and-github); sin embargo, puedes utilizar git como quieras.

- Asegúrate de incluir en la lista "chatarra" como `.DS_Store` en .gitignore. Puede que encuentres el [paquete gitignore](https://docs.ropensci.org/gitignore/) relevante.

- Una sección posterior de este libro contiene algunos [consejos sobre el flujo de trabajo de git](#gitflow).

## Gotas varias de CRAN {#crangotchas}

Esta es una colección de gotchas de CRAN que vale la pena evitar desde el principio.

- Asegúrate de que el título de tu paquete está en mayúsculas.
- No pongas un punto al final de tu título.
- No pongas "en R" o "con R" en tu título, ya que esto es obvio en los paquetes alojados en CRAN. Si, a pesar de todo, quieres que esta información se muestre en tu sitio web, comprueba el [`pkgdown` documentación](https://pkgdown.r-lib.org/reference/build_home.html#yaml-config-home) para saber cómo anularlo.
- Evita empezar la descripción con el nombre del paquete o "Este paquete...".
- Asegúrate de incluir enlaces a sitios web si envuelves una API web, raspas datos de un sitio, etc. en la `Descripción` de tu `DESCRIPCIÓN` de tu archivo DESCRIPTION. Las URL deben ir entre corchetes, por ejemplo `<https://www.r-project.org>`.
- Tanto en el `Título` como en `Descripción` los nombres de los paquetes u otro software externo deben ir entre comillas simples (por ejemplo *Integración de 'Rcpp' para la Biblioteca de Álgebra Lineal Templada 'Armadillo*).
- Evita las pruebas y los ejemplos de larga duración.  Considera `testthat::skip_on_cran` en las pruebas para omitir las cosas que llevan mucho tiempo, pero sigue probándolas localmente y en [integración continua](#ci).
- Incluye archivos de alto nivel como `paper.md`en los archivos de configuración de integración continua, en tu archivo `.Rbuildignore` de Rbuildignore.

### Comprobaciones de CRAN {#cranchecks}

Una vez que tu paquete esté en CRAN, será [comprobado regularmente en diferentes plataformas](https://blog.r-hub.io/2019/04/25/r-devel-linux-x86-64-debian-clang/#cran-checks-101). Los fallos de estas comprobaciones, cuando no son falsos positivos, pueden hacer que el equipo de CRAN se ponga en contacto con él. Puedes controlar el estado de las comprobaciones de CRAN a través de

- el sitio web [`foghorn` paquete](https://fmichonneau.github.io/foghorn/).

- el [API de comprobación de CRAN](https://github.com/ropenscilabs/cchecksapi) mantenida por rOpenSci, que proporciona [insignias](https://github.com/ropenscilabs/cchecksapi#badges).

## Trucos de Bioconductor

Si pretendes que tu paquete se envíe a Bioconductor, o si tu paquete está en Bioconductor, consulta [Directrices de empaquetado de Bioconductor](https://www.bioconductor.org/developers/package-guidelines/).

## Otras orientaciones

- Si envías un paquete a rOpenSci a través del [repo de software-review](https://github.com/ropensci/software-review)puedes dirigir tus preguntas al equipo de rOpenSci a través del gestor de incidencias o en nuestro [foro de discusión](https://discuss.ropensci.org/).

- Antes de enviar un paquete, utiliza las [**buenas prácticas**](https://github.com/MangoTheCat/goodpractice) (`goodpractice::gp()`) como guía para mejorar tu paquete, ya que la mayoría de las excepciones al mismo tendrán que justificarse. Por ejemplo, el uso de `foo` puede ser generalmente malo y, por tanto, marcado por `buenas prácticas` pero tú tenías una buena razón para utilizarlo en tu paquete.

- Lee, incorpora y actúa según los consejos de la [*Guía de Colaboración* capítulo](#collaboration).

### Aprender sobre el desarrollo de paquetes

#### Libros

- [Hadley Wickham y Jenny Bryan *Paquetes R* libro](https://r-pkgs.org/) es un recurso excelente y fácil de leer sobre el desarrollo de paquetes que está disponible [gratis en línea](https://r-pkgs.org/) (y [impreso - enlace a la versión anterior de Hadley Wickham, ya que la nueva versión aún no se ha publicado en junio de 2022](https://www.amazon.com/Packages-Organize-Test-Document-Share/dp/1491910593)).

- [Escribir extensiones de R](https://cran.r-project.org/doc/manuals/r-release/R-exts.html) es la referencia canónica, normalmente la más actualizada, para crear paquetes de R.

- [*Dominio del desarrollo de software en R* por Roger D. Peng, Sean Kross y Brooke Anderson](https://bookdown.org/rdpeng/RProgDA/).

- [*R avanzado* de Hadley Wickham](https://adv-r.hadley.nz/)

#### Tutoriales

- [La famosa entrada del blog de Hilary Parker *Escribir un paquete de R desde cero*](https://hilaryparker.com/2014/04/29/writing-an-r-package-from-scratch/) o [su versión actualizada por Tomas Westlake](https://r-mageddon.netlify.com/post/writing-an-r-package-from-scratch/) que muestra cómo hacer lo mismo de forma más eficiente utilizando `usethis`.

- [esta descripción del flujo de trabajo de Emil Hvitfeldt](https://www.emilhvitfeldt.com/post/2018-09-02-usethis-workflow-for-package-development/).

- [Esta imagen de Matthew J Denny](https://www.mjdenny.com/R_Package_Pictorial.html).

#### Blogs

- [Blog de R-hub](https://blog.r-hub.io/post).

- Algunos posts del [blog de rOpenSci](https://ropensci.org/archive/) por ejemplo ["Cómo precomputar viñetas de paquetes o artículos pkgdown"](https://ropensci.org/blog/2019/12/08/precompute-vignettes/).

- Sección del Rincón del Desarrollo de Paquetes del [boletín de rOpenSci](https://ropensci.org/news/).

- Algunos posts del [blog tidyverse](https://www.tidyverse.org) por ejemplo ["Actualizando a la edición 3 de testthat".](https://www.tidyverse.org/blog/2022/02/upkeep-testthat-3/).

#### MOOCs

Existe una [especialización de Coursera correspondiente al libro de Roger Peng, Sean Kross y Brooke Anderson](https://fr.coursera.org/specializations/r)con un curso específico sobre los paquetes de R.

[curl]: https://github.com/jeroen/curl/
[crul]: https://github.com/ropensci/crul/
[httr]: https://httr.r-lib.org
[httr2]: https://httr2.r-lib.org
[RCurl]: https://cran.rstudio.com/web/packages/RCurl/
[webmockr]: https://github.com/ropensci/webmockr/
[vcr]: https://github.com/ropensci/vcr/
[jsonlite]: https://github.com/jeroen/jsonlite
[rjson]: https://cran.rstudio.com/web/packages/rjson/
[RJSONIO]: https://cran.rstudio.com/web/packages/RJSONIO/
[xml2]: https://cran.rstudio.com/web/packages/xml2/
[sp]: https://github.com/edzer/sp/
[sf]: https://r-spatial.github.io/sf/
[rgdal]: https://cran.r-project.org/web/packages/rgdal/index.html
[maptools]: https://cran.r-project.org/web/packages/maptools/index.html
[rgeos]: https://cran.r-project.org/web/packages/rgeos/index.html



